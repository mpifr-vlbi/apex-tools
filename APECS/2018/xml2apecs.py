#!/usr/bin/env python
'''
Usage: xml2apecs.py <xmlfile>

Produces an .obs file that contains timed APECS commands for the VLBI observation.
The input xml file is expected to have been generated by Haystack vex2xml.py.
The .obs file can later be run with apecsVLBI.py. Does not yet support frequency
changes during an observation (different MODEs in VEX).

Note, source coordinates are not part of the Haystack xml file; coordinates can be
extracted into an APEX .cat file using the script vexGetSources2cat.py.
'''

import sys
import datetime
import xml.etree.ElementTree as ET
import ntpath

def coordReformat(s):
	s = s.strip()
	repl = list('hmd\'')
	for c in repl:
		s = s.replace(c,':')
	s = s.replace('s','')
	s = s.replace('"','')
	return s
	# Note APECS wants reformatting
	# RA:  VEX 13h25m27.6152000s  --> APECS 13:25:27.6152000
	# DEC: VEX -43d01\'08.805000" --> APECS -43:01:08.80500

def datetime2SNP(t):
	# Example SNP timestamp: 2015.016.07:30:00
	return t.strftime('%Y.%j.%H:%M:%S')

def VEX2datetime(tvex):
	# Example VEX timestamp: 2015y016d07h30m00s
	return datetime.datetime.strptime(tvex, '%Yy%jd%Hh%Mm%Ss')

def xml2datetime(txml):
	# Example XML timestamp: 2018111223100 (yyyydddhhmmss)
	return datetime.datetime.strptime(txml, '%Y%j%H%M%S')

def getAllScans(xmlfile):
	scans = []
	tree = ET.parse(xmlfile)
	root = tree.getroot()
	for child in root:
		scan = child.attrib
		entry = {'name': scan['scan_name'], 'source': scan['source']}
		entry['start'] = xml2datetime(scan['start_time'])
		entry['dur'] = int(scan['duration'])
		scans.append(entry)
	return scans

def obs_writeLine(fd, time,dur,cmd):
	fd.write('%-22s %-10s %s\n' % (time,str(dur),cmd))

def obs_writeHeader(fd,vexfn):
	T = datetime.datetime.utcnow()
	T = datetime2SNP(T)
	fd.write('#\n')
	fd.write('# APEX observing script from file %s\n' % (vexfn))
	fd.write('# File created on %s UT\n' % (T))
	fd.write('#\n')
	fd.write('# Columns: 1) Start time 2) Duration in seconds 3) APECS command \n')
	fd.write('# Details on the columns:\n')
	fd.write('#    1) @always, or UT date-time in a 2015.016.06:42:40 format (yyyy.doy.hh:mm:ss)\n')
	fd.write('#         modifiers: !2015.016.06:42:40 to not skip command even if start time already is past\n')
	fd.write('#    2) estimated duration of the command in seconds\n')
	fd.write('#    3) APECS command and parameters to execute. If the command includes whitespace.\n')
	fd.write('#       Commands include, e.g.: tsys(), interactive("message"), tracksource("sourcename"), ...\n')
	fd.write('#\n')
	fd.write('# %-20s %-10s %s\n' % ('At time', 'Duration', 'Command'))

def obs_writeFooter(fd):
	fd.write('%s\n' % (80*'#'))
	fd.write('### end of schedule\n')
	fd.write('%s\n' % (80*'#'))

def obs_writeStandardsetup(fd):
	obs_writeLine(fd, '@always',  10, 'execfile(\'pi230_setup.apecs\')')
	obs_writeLine(fd, '@always',  2, 'execfile(\'vlbi-pi230_commands.py\')')
	fd.write('\n')

def obs_writeScans(fd,scans):

	Lslew    = 25  # max slew time in seconds to a new source
	Ltsys    = 20  # max time for Tsys sky/hot/cold measurement in seconds
	Lrefscan = 70  # max time for on() scan with Off-Source reference
	Lcmdmargin = 5 # allow 5 seconds between issuing any new APECS command
	L_minimum_for_interactive = 9999999 # seconds required to allow interactive input from observer

	Tstart_next = None  # keep track of starting time of scan after current one
	prev_source = None  # keep track of source changes
	Tprev_end = None

	for scan in scans:
		ii = scans.index(scan)

		T = scan['start']
		Ldur = scan['dur']
		
		# Determine scan after current one (time margin, source name)
		if ii < (len(scans)-1):
			iinext = ii + 1
			nextscan = scans[iinext]
			Tstart_next = nextscan['start']
			# Time delta from end of current scan to start of next scan
			dT_to_next = (Tstart_next - T).total_seconds()
			dT_to_next = dT_to_next - Ldur
		else:
			nextscan = None
			Tstart_next = None
			dT_to_next = 9999999

		# Determine what things to do during current scan
		do_sourcechange = False
		do_vlbi_reference_scan = False
		do_vlbi_tsys = False
		L_start_early = 0

		if (ii == 0) or (scan['source'] != prev_source):
			do_sourcechange = True
			L_start_early = L_start_early + Lslew + Lcmdmargin

		if (dT_to_next - L_start_early) > Ltsys:
			do_vlbi_tsys = True
			L_start_early = L_start_early + Ltsys + Lcmdmargin

		if (dT_to_next - L_start_early) > Lrefscan:
			do_vlbi_reference_scan = True
			L_start_early = L_start_early + Lrefscan + Lcmdmargin

		# Determine the time between the end of the previous scan, and the first command for this scan
		if (Tprev_end != None):
			Tfirstcmd = T - datetime.timedelta(seconds=L_start_early)
			Lscangap = (Tfirstcmd - Tprev_end)
			Lscangap = Lscangap.total_seconds()
			if (Lscangap >= L_minimum_for_interactive):
				msg = 'About %d seconds available for pointing/focusing/other' % (int(Lscangap))
				obs_writeLine(fd, datetime2SNP(T), 0, 'interactive(\'%s\')' % (msg))
			fd.write('#     scan end at %s\n' % datetime2SNP(Tprev_end))
			fd.write('#     %d idle seconds (%.1f minutes) until next remote command\n\n' % (int(Lscangap),Lscangap/60.0) )

		# Now queue up the APECS commands to do for this scan
		sheading = 'Target %s scanname %s to start at %s' % (scan['source'],scan['name'],datetime2SNP(scan['start']))
		fd.write('#### %s %s\n' % (sheading, '#'*(80-6-len(sheading))))
		T = T - datetime.timedelta(seconds=L_start_early)
		if do_sourcechange:
			obs_writeLine(fd, datetime2SNP(T), Lslew, 'source(\'%s\'); go(); track()' % (scan['source']))
			T = T + datetime.timedelta(seconds=(Lslew+Lcmdmargin))
		if do_vlbi_tsys:
			obs_writeLine(fd, datetime2SNP(T), Ltsys, 'vlbi_tsys()')
			T = T + datetime.timedelta(seconds=(Ltsys+Lcmdmargin))
		if do_vlbi_reference_scan:
			obs_writeLine(fd, datetime2SNP(T), Lrefscan, 'vlbi_reference_scan()')
			T = T + datetime.timedelta(seconds=(Lrefscan+Lcmdmargin))
		obs_writeLine(fd, datetime2SNP(T), scan['dur'], 'vlbi_scan(t_mins=%d)' % (scan['dur']/60))  # track on source
		T = T + datetime.timedelta(seconds=Ldur)
		if not do_vlbi_tsys:
			# Tsys after scan?
			pass

		prev_source = scan['source']
		Tprev_end = T

	fd.write('\n# Finished VLBI schedule\n')
	obs_writeLine(fd, datetime2SNP(T), 1, 'remote_control(\'off\')')


def run(args):
	global src_file, lin_file

	if (len(args) != 2):
		print(__doc__)
		sys.exit(-1)
	xmlfile = args[1]

	scans = getAllScans(xmlfile)
	if len(scans) < 1:
		print ('\nError: no scans found in %s!\n' % (xmlfile))
		return

	obsfile = ntpath.basename(xmlfile)
	obsfile = obsfile.replace('.xml', '.apecs.obs')

	fd = open(obsfile, 'w')
	obs_writeHeader(fd,xmlfile)
	obs_writeStandardsetup(fd)
	obs_writeScans(fd,scans)
	obs_writeFooter(fd)
	fd.close()

	print ('\nDone. Created APECS observing file %s with %d scans.\n' % (obsfile,len(scans)))


run(sys.argv)
