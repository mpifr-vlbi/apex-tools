#!/usr/bin/env python

import sys
import datetime
import xml.etree.ElementTree as ET
import ntpath

def usage():
	print ('')
	print ('Usage: xml2apecs.py <xmlfile>')
	print ('')
	print ('Produces an .obs file that contains timed APECS commands for the VLBI observation.')
	print ('The input xml file is expected to have been generated by Haystack vex2xml.py.')
	print ('The .obs file can later be run with apecsVLBI.py. Does not yet support frequency')
	print ('changes during an observation (different MODEs in VEX).')
	print ('')
	print ('Note, source coordinates are not part of the Haystack xml file; coordinates can be')
	print ('extracted into an APEX .cat file using the script vexGetSources2cat.py.')
	print ('')

def coordReformat(s):
	s = s.strip()
	repl = list('hmd\'')
	for c in repl:
		s = s.replace(c,':')
	s = s.replace('s','')
	s = s.replace('"','')
	return s
	# Note APECS wants reformatting
	# RA:  VEX 13h25m27.6152000s  --> APECS 13:25:27.6152000
	# DEC: VEX -43d01\'08.805000" --> APECS -43:01:08.80500

def datetime2SNP(t):
	# Example SNP timestamp: 2015.016.07:30:00
	return t.strftime('%Y.%j.%H:%M:%S')

def VEX2datetime(tvex):
	# Example VEX timestamp: 2015y016d07h30m00s
	return datetime.datetime.strptime(tvex, '%Yy%jd%Hh%Mm%Ss')

def xml2datetime(txml):
	# Example XML timestamp: 2018111223100 (yyyydddhhmmss)
	return datetime.datetime.strptime(txml, '%Y%j%H%M%S')

def getAllScans(xmlfile):
	scans = []
	tree = ET.parse(xmlfile)
	root = tree.getroot()
	for child in root:
		scan = child.attrib
		entry = {'name': scan['scan_name'], 'source': scan['source']}
		entry['start'] = xml2datetime(scan['start_time'])
		entry['dur'] = int(scan['duration'])
		scans.append(entry)
	return scans

def obs_writeLine(fd, time,dur,cmd):
	fd.write('%-22s %-10s %s\n' % (time,str(dur),cmd))

def obs_writeHeader(fd,vexfn):
	T = datetime.datetime.utcnow()
	T = datetime2SNP(T)
	fd.write('#\n')
	fd.write('# APEX observing script from file %s\n' % (vexfn))
	fd.write('# File created on %s UT\n' % (T))
	fd.write('#\n')
	fd.write('# Columns: 1) Start time 2) Duration in seconds 3) APECS command \n')
	fd.write('# Details on the columns:\n')
	fd.write('#    1) @always, or UT date-time in a 2015.016.06:42:40 format (yyyy.doy.hh:mm:ss)\n')
	fd.write('#         modifiers: !2015.016.06:42:40 to not skip command even if start time already is past\n')
	fd.write('#    2) estimated duration of the command in seconds\n')
	fd.write('#    3) APECS command and parameters to execute. If the command includes whitespace.\n')
	fd.write('#       Commands include, e.g.: tsys(), interactive("message"), tracksource("sourcename"), ...\n')
	fd.write('#\n')
	fd.write('# %-20s %-10s %s\n' % ('At time', 'Duration', 'Command'))

def obs_writeFooter(fd):
	fd.write('%s\n' % (80*'#'))
	fd.write('### end of schedule\n')
	fd.write('%s\n' % (80*'#'))

def obs_writeStandardsetup(fd):
	obs_writeLine(fd, '@always',  10, 'execfile(\'pi230_setup.apecs\')')
	obs_writeLine(fd, '@always',  2, 'execfile(\'vlbi-pi230_commands.py\')')
	fd.write('\n')

def obs_writeScans(fd,scans):

	Lslew   = 30  # slew time in seconds typical to a new source
	Lpre    = 30  # preobs  x seconds before scan
	Lcalib  = 50  # postobs x seconds after scan; calibrate takes ~40seconds max
	L_minimum_for_interactive = 9999999 # seconds required to allow interactive input from observer
	Tstart_next = None

	for scan in scans:
		ii = scans.index(scan)

		sheading = 'Target %s scanname %s to start at %s' % (scan['source'],scan['name'],datetime2SNP(scan['start']))
		fd.write('#### %s %s\n' % (sheading, '#'*(80-6-len(sheading))))

		T = scan['start']
		Ldur = scan['dur']
		
		if ii < (len(scans)-1):
			nextscan = scans[ii+1]
			Tstart_next = nextscan['start']
		else:
			Tstart_next = None

		# Start early
		T = T - datetime.timedelta(seconds=(Lpre+Lslew))

		# Go to source (slew time)
		obs_writeLine(fd, datetime2SNP(T), Lslew-5, 'source(\'%s\'); go()' % (scan['source']))
		T = T + datetime.timedelta(seconds=Lslew)

		# Run some pre-calibrations that APECS operators wanted to do
		obs_writeLine(fd, datetime2SNP(T), Lpre-5, 'vlbi_tp_onsource_prepare(\'%s\')' % (scan['source']))
		T = T + datetime.timedelta(seconds=Lpre)

		# Track on source for the duration of the scan (Ldur), and get Tsys at end of scan (Lcalib; part of vlbi_tp_onsource())
		obs_writeLine(fd, datetime2SNP(T), scan['dur'], 'vlbi_tp_onsource(src=\'%s\',t=%d)'  % (scan['source'],scan['dur']/60))
		T = T + datetime.timedelta(seconds=Ldur)
		T = T + datetime.timedelta(seconds=Lcalib)

		if (Tstart_next != None):
			Lscangap = (Tstart_next - T)
			Lscangap = Lscangap.total_seconds()
			if (Lscangap >= L_minimum_for_interactive):
				msg = 'About %d seconds available for pointing/focusing/other' % (int(Lscangap)) 
				obs_writeLine(fd, datetime2SNP(T), 0, 'interactive(\'%s\')' % (msg))
			fd.write('#     %d seconds (%.1f minutes) until next scan\n\n' % (int(Lscangap),Lscangap/60.0) )

	fd.write('\n# Finished VLBI schedule\n')
	obs_writeLine(fd, datetime2SNP(T), 1, 'remote_control(\'off\')')


def run(args):
	global src_file, lin_file

	if (len(args) != 2):
		usage()
		sys.exit(-1)
	xmlfile = args[1]

	scans = getAllScans(xmlfile)
	if len(scans) < 1:
		print ('\nError: no scans found in %s!\n' % (xmlfile))
		return

	obsfile = ntpath.basename(xmlfile)
	obsfile = obsfile.replace('.xml', '.apecs.obs')

	fd = open(obsfile, 'w')
	obs_writeHeader(fd,xmlfile)
	obs_writeStandardsetup(fd)
	obs_writeScans(fd,scans)
	obs_writeFooter(fd)
	fd.close()

	print ('\nDone. Created APECS observing file %s with %d scans.\n' % (obsfile,len(scans)))


run(sys.argv)
