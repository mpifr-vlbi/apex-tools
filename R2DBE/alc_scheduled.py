#!/usr/bin/env python
'''
Usage: alc_scheduled.py <xmlfile>

Carries out automatic level control (8-bit -> 2-bit conversion threshold levels)
on four R2DBEs assumed to be named 'r2dbe1' to 'r2dbe4'. The ALC is performed
a few seconds befor the start of a VLBI scan according to a Mark6 recorder
schedule given in <xmlfile>. The input xml file is expected to have been
generated by Haystack vex2xml.py. 
'''

import sys
import datetime, time
import xml.etree.ElementTree as ET
import logging
from math import log10, sqrt

import mandc
#from mandc.r2dbe import R2dbe, R2DBE_INPUTS

IDEAL_THRESHOLD = 30        # ideal R2DBE threshold value
AT_SECS_BEFORE_SCAN = 10    # run ALC roughly how many seconds before a scan
SECS_MARGIN = 2             # allow ALC to be done during AT_SECS_BEFORE_SCAN +- SECS_MARGIN

'''Convert XML time string (e.g. 2018111223100, yyyydddhhmmss) into datetime'''
def xml2datetime(txml):
	return datetime.datetime.strptime(txml, '%Y%j%H%M%S')

'''Convert datetime into Fieldsystem/SNP time format'''
def datetime2SNP(t):
	# Example SNP timestamp: 2015.016.07:30:00
	return t.strftime('%Y.%j.%H:%M:%S')

'''Run ALC for one R2DBE, as in alc.py'''
def alc_r2dbe(hostname, logger):
	global IDEAL_THRESHOLD

	# Set thresholds
	r2dbe = mandc.r2dbe.R2dbe(hostname)
	for inp in R2DBE_INPUTS:
		r2dbe.set_2bit_threshold(inp)		

	# Get thresholds and log them
	th = r2dbe.get_2bit_threshold(list(mandc.r2dbe.R2DBE_INPUTS))
	logger.info("Thresholds for {host!r} set to if0={th[0]}, if1={th[1]}".format(host=r2dbe, th=th))

	# Estimate required change in input power for optimal setting
	d_pwr = [(IDEAL_THRESHOLD / (1.0 * t))**2 for t in th]
	d_pwr_dB = [10.0 * log10(d) for d in d_pwr]
	logger.info("Recommended change in input power for {host!r} is if0 = {dp[0]:+.2f} dB, if1 = {dp[1]:+.2f} dB".format(host=r2dbe, dp=d_pwr_dB))

'''Create a logger, as in alc.py'''
def configure_logging(logfilename=None, verbose=None):
	# Set up root logger
	logger = logging.getLogger()
	logger.setLevel(logging.INFO)
	
	# Always add logging to stdout
	stdout_handler = logging.StreamHandler(sys.stdout)
	all_handlers = [stdout_handler]
	# And optionally to file
	if logfilename:
		file_handler = logging.FileHandler(logfilename, mode="a")
		all_handlers.append(file_handler)
	# Add handlers
	for handler in all_handlers:
		logger.addHandler(handler)

	# Silence all katcp messages, except CRITICAL
	katcp_logger = logging.getLogger('katcp')
	katcp_logger.setLevel(logging.CRITICAL)

	# If verbose, set level to DEBUG on file, or stdout if no logging to file
	if verbose:
		# First set DEBUG on root logger
		logger.setLevel(logging.DEBUG)
		# Then revert to INFO on 0th handler (i.e. stdout)
		all_handlers[0].setLevel(logging.INFO)
		# Finally DEBUG again on 1th handler (file if it exists, otherwise stdout again)
		all_handlers[-1].setLevel(logging.DEBUG)

	# Create and set formatters
	formatter = logging.Formatter('%(name)-30s: %(asctime)s : %(levelname)-8s %(message)s')
	for handler in all_handlers:
		handler.setFormatter(formatter)

	# Initial log messages
	logger.info("Started logging in {filename}".format(filename=__file__))
	if logfilename:
		logger.info("Log file is '{log}'".format(log=logfilename))

	# Return root logger
	return logger

if len(sys.argv) != 2:
	print (__doc__)
	sys.exit(1)

logger = configure_logging()
xmlfile = sys.argv[1]

tree = ET.parse(xmlfile)
root = tree.getroot()
for child in root:
	scaninfos = child.attrib

	T_scan = xml2datetime(scaninfos['start_time'])
	T_early = T_scan - datetime.timedelta(seconds=5)

	while True:
		T_now =  datetime.datetime.utcnow()
		dT = T_early - T_now
		dT = dT.total_seconds()
		if (dT > (AT_SECS_BEFORE_SCAN - SECS_MARGIN)) and (dT < (AT_SECS_BEFORE_SCAN + SECS_MARGIN)):
			for host in ['r2dbe1','r2dbe2','r2dbe3','r2dbe4']:
				alc_r2dbe(host, logger)
			break #  advance to next scan
		elif (dT < (AT_SECS_BEFORE_SCAN - SECS_MARGIN)):
			print('Skipping scan %s at %s' % (scaninfos['scan_name'],scaninfos['start_time']))
			break
		else:
			time.sleep(0.25)
			sys.stdout.write('\r')
	                sys.stdout.write('Still %ds to be %d+-%ds before start %s of scan %s' % (int(dT),AT_SECS_BEFORE_SCAN,SECS_MARGIN,datetime2SNP(T_scan),scaninfos['scan_name']))
        	        sys.stdout.flush()
